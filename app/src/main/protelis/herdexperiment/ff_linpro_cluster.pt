module herdexperiment:ff_linpro_cluster
import protelis:lang:utils
import protelis:coord:spreading
import protelis:coord:accumulation
import it.unibo.experiment.herdexperiment.MyUtils.getClusterSolver
import it.unibo.experiment.herdexperiment.MyUtils.findNonCollidingPosition
import it.unibo.experiment.herdexperiment.MyUtils.getAssignedNodes
import it.unibo.experiment.ProtelisUtils.getCenterOfFovAtDistance
import it.unibo.experiment.ProtelisUtils.closestPositionToTargetAtDistance
import utils
import exploration_strategies
import it.unibo.experiment.ProtelisUtils.toTuple
import herdexperiment:adaptive_clustering

def arePositionsClose(a, b) {
    (normalize(a.get(0)) == normalize(b.get(0))) && (normalize(a.get(1)) == normalize(b.get(1)))
}

def normalize(coordinate) {
    let factor = 5
    round(coordinate / factor) * factor
}

public def myFollowOrExplore(cluster, explorationStrategy) =
  if(cluster == noTarget()) {
      explorationStrategy()
      noTarget()
  } else {
      env.put("Protelis target:", cluster)
      myfollow(cluster.getCentroid())
  }


public def myfollow(target) {
    envRemove("doSpin")
    envRemove("doZigZag")
    env.put("destination", closestPositionToTargetAtDistance(target, mygetFoVCenterDistance()));
    env.put("heading", target);
    target
}

public def mygetFoVCenterDistance() {
    // 2 * getFoVDistance() / 3
    getFoVDistance() / 2
}

public def myavoidCameraCollision(cluster, localTargets) =
    if(cluster != noTarget() && localTargets.contains(cluster)) {
        let assignedTs = nbr(cluster.getCentroid())
        let pos = findNonCollidingPosition(assignedTs, env.get("destination"), cluster.getCentroid(), getFoVCenterDistance())
        env.put("destination", pos)
    } else { 0 }

rep(solver <- getClusterSolver()) {
    let localTargets = getLocalTargets()
    let externalTargets = foldUnion([], nbr(localTargets))
    let targets = localTargets.union(externalTargets)
    let cameras = nbr(getCenterOfFov())


    let clusters = solver.getClustersOfVisibleNodes(targets, env.get("ClusteringLimit"))
    env.put("Clusters", clusters) // Used by GUI cluster drawing
    let solved = solver.solve(cameras, clusters, getMaxCamerasPerTarget(), false)
    env.put("solved", solved)
    let assignedNodes = getAssignedNodes(solved, clusters)
    env.put("solved nodes", assignedNodes)
    let myCluster = solved.getOrDefault(getUID(), noTarget())

    let allTarget = solved.values()
    myFollowOrExplore(myCluster, fieldExploration)
    myavoidCameraCollision(myCluster, allTarget)
    env.put("ClusteringLimit", getNewClusterLimit(clusters, myCluster, localTargets, assignedNodes, externalTargets))
    solver
}


