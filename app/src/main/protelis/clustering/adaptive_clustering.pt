module clustering:adaptive_clustering
import it.unibo.experiment.clustering.HerdExperimentUtils.isClusterCentroidVisible
import clustering:utils_c


public def getNewClusteringDistance(myCluster, localVisibleNodes, allAssignedNodes){
    let allClusteringDistances = foldUnion([getClusteringDistance()], nbr(getClusteringDistance()))
    let myClusterNodes = tupleOf(myCluster.getNodes())
    let allVisibleNotTargetNodes = foldUnion(nbr(localVisibleNodes.subtract(myClusterNodes))) // Nodes that are visible but are not part of target clusters
    if(myCluster != emptyCluster()){
        let myClusterVisibleNodesSize = localVisibleNodes.intersection(myClusterNodes).size()

        if(isClusterCentroidVisible(myCluster)) { // the device already arrived at his destination
            let isClusterCovered = myClusterVisibleNodesSize == myClusterNodes.size()
            if(isClusterCovered){ // device cover all nodes of its cluster
                getClusteringDistanceWithCoveredCluster(localVisibleNodes, allAssignedNodes, myClusterNodes, allVisibleNotTargetNodes, allClusteringDistances)
            }else{
                getClusteringDistanceWithNotCoveredCluster(localVisibleNodes, myClusterNodes, myClusterVisibleNodesSize, allClusteringDistances) 
            }
        }else{
            env.put("->>>>>>>>>>>>>>>>>>>>", "a2")
            adapt(allClusteringDistances)
        }
    }else{
        env.put("->>>>>>>>>>>>>>>>>>>>", "a1")
        adapt(allClusteringDistances)
    }
}  


def getClusteringDistanceWithCoveredCluster(localVisibleNodes, allAssignedNodes, myClusterNodes, allVisibleNotTargetNodes, allClusteringDistances){
    let unionSize = localVisibleNodes.union(myClusterNodes).size() 
    if(unionSize > myClusterNodes.size()){ // device cover nodes from other clusters
        let extraneous = localVisibleNodes.subtract(myClusterNodes)
        let extraneousCoverage = extraneous.size() / localVisibleNodes.size()
        if(!allAssignedNodes.containsAll(extraneous) || extraneousCoverage > 0.5){
            env.put("->>>>>>>>>>>>>>>>>>>>", "i")
            max(increment(), allClusteringDistances.max(0))
        }else{
            env.put("->>>>>>>>>>>>>>>>>>>>", "a3")
            adapt(allClusteringDistances)
        }
    }else{
        adapt(allClusteringDistances)
    }
}

def getClusteringDistanceWithNotCoveredCluster(localVisibleNodes, myClusterNodes, myClusterVisibleNodesSize, allClusteringDistances) {
    let myClusterCoverage = myClusterVisibleNodesSize / myClusterNodes.size()
    if(myClusterVisibleNodesSize == localVisibleNodes.size() && myClusterCoverage < 0.7 ){
        env.put("->>>>>>>>>>>>>>>>>>>>", "d")
        min(decrement(), allClusteringDistances.min(0))
    }else{
        env.put("->>>>>>>>>>>>>>>>>>>>", "a4")
        adapt(allClusteringDistances)
    }
}

def adapt(list) = list.reduce(0, (a, b) -> {a + b}) / list.size()

def increment() {
   let clusteringDistance = getClusteringDistance()
   clusteringDistance + (clusteringDistance * 0.02)
}

def decrement(){
    let clusteringDistance = getClusteringDistance()
    clusteringDistance - (clusteringDistance * 0.02)
}