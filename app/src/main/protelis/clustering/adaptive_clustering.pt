module clustering:adaptive_clustering
import it.unibo.experiment.ProtelisUtils.toTuple
import it.unibo.experiment.clustering.HerdExperimentUtils.isClusterCentroidVisible
import clustering:utils_c


public def getNewClusterLimit(cluster, localVisibleNodes, assignedNodes){
    let allLimits = foldUnion([getClusteringLimit()], nbr(getClusteringLimit()))
    let clusterNodes = toTuple(cluster.getPoints())
    let excludedTargets = foldUnion(nbr(localVisibleNodes.subtract(clusterNodes))) // Nodes that are visible but are not part of target clusters
    if(cluster != emptyCluster()){
        let intersectionSize = localVisibleNodes.intersection(clusterNodes).size()

        if(isClusterCentroidVisible(cluster)) {
            let isClusterCovered = intersectionSize == clusterNodes.size()
            if(isClusterCovered){
                getLimitWithCoveredCluster(localVisibleNodes, assignedNodes, clusterNodes, excludedTargets, allLimits)
            }else{
                getLimitWithNotCoveredCluster(localVisibleNodes, clusterNodes, intersectionSize, allLimits) 
            }
        }else{
            adapt(allLimits)
        }
    }else{
        adapt(allLimits)
    }
}  


def getLimitWithCoveredCluster(localVisibleNodes, assignedNodes, clusterNodes, excludedTargets, allLimits){
    let unionSize = localVisibleNodes.union(clusterNodes).size() 
    if(unionSize > clusterNodes.size()){
        let difference = localVisibleNodes.subtract(clusterNodes)
        if(assignedNodes.containsAll(difference) && (clusterNodes.subtract(excludedTargets).size() / localVisibleNodes.size()) > 0.0){
            adapt(allLimits)
        }else{
            max(increment(), allLimits.max(0))
        }
    }else{
        adapt(allLimits)
    }
}

def getLimitWithNotCoveredCluster(localVisibleNodes, clusterNodes, intersectionSize, allLimits) {
    let coverage = intersectionSize / clusterNodes.size()
    if(intersectionSize == localVisibleNodes.size() && coverage < 0.9 ){
        min(decrement(), allLimits.min(0))
    }else{
        adapt(allLimits)
    }
}

def adapt(list) = list.reduce(0, (a, b) -> {a + b}) / list.size()

def increment() {
   let limit = getClusteringLimit()
   limit + (limit * 0.01)
}

def decrement(){
    let limit = getClusteringLimit()
    limit - (limit * 0.01)
}